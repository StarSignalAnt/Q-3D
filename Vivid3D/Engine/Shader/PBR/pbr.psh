#define PI 3.14159265359

Texture2D v_Texture;
SamplerState v_Texture_sampler;
Texture2D v_TextureNormal;
SamplerState v_TextureNormal_sampler;
Texture2D v_TextureMetal;
SamplerState v_TextureMetal_sampler;
Texture2D v_TextureRough;
SamplerState v_TextureRough_sampler;

cbuffer Constants
{
    float4x4 g_ModelMatrix;
    float4x4 g_ViewMatrix;
    float4x4 g_ProjectionMatrix;
    float4x4 g_MVPMatrix;
    float4x4 g_NormalMatrix;

    float4 g_CameraPosition;
    float4 g_LightPosition;
    float4 g_LightColor;
    float4 g_LightIntensity;
    float4 g_LightRange;
    
    // New parameters for enhancements
    float4 g_ToneMapParams;  // x: Exposure, y: Gamma, z: AmbientStrength, w: unused
    float4 g_AmbientColor;   // Ambient light color (w component unused)
};

struct PSInput {
    float4 Pos : SV_POSITION;
    float3 Uv : TEXCOORD0;
    float4 v_Color : TEXCOORD1;
    float3 WorldPos : TEXCOORD2;
    float3 Normal : TEXCOORD3;
    float3 Tangent : TEXCOORD4;
    float3 Binormal : TEXCOORD5;
};

struct PSOutput {
    float4 Color : SV_TARGET;
};

// Tone mapping functions
float3 ReinhardToneMapping(float3 color)
{
    return color / (color + float3(1.0, 1.0, 1.0));
}

float3 FilmicToneMapping(float3 color)
{
    color = max(float3(0.0, 0.0, 0.0), color - float3(0.004, 0.004, 0.004));
    color = (color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06);
    return color;
}

float3 ACESFilmicToneMapping(float3 color)
{
    float a = 2.51;
    float b = 0.03;
    float c = 2.43;
    float d = 0.59;
    float e = 0.14;
    return saturate((color * (a * color + b)) / (color * (c * color + d) + e));
}

float3 ExposureToneMapping(float3 color, float exposure)
{
    return float3(1.0, 1.0, 1.0) - exp(-color * exposure);
}

// Unpacks normal map and corrects green-channel handedness
float3 getNormalFromMap(float3 normalMap, float3 worldNormal, float3 worldTangent, float3 worldBinormal)
{
    float3 n = normalMap * float3(2.0, 2.0, 2.0) + float3(-1.0, -1.0, -1.0);
    float3x3 TBN = float3x3(worldTangent, worldBinormal, worldNormal);
    return normalize(mul(n, TBN));
}

float DistributionGGX(float3 N, float3 H, float rough)
{
    float a = rough * rough;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH * NdotH;

    float num = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;

    return num / denom;
}

float GeometrySchlickGGX(float NdotV, float rough)
{
    float r = rough + 1.0;
    float k = (r * r) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

float GeometrySmith(float3 N, float3 V, float3 L, float rough)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx1 = GeometrySchlickGGX(NdotL, rough);
    float ggx2 = GeometrySchlickGGX(NdotV, rough);
    return ggx1 * ggx2;
}

float3 fresnelSchlick(float cosTheta, float3 F0)
{
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

// Enhanced Fresnel with roughness consideration
float3 fresnelSchlickRoughness(float cosTheta, float3 F0, float roughness)
{
    return F0 + (max(float3(1.0 - roughness, 1.0 - roughness, 1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

void main(in PSInput I, out PSOutput O)
{
    // Sample material properties
    float4 albedo = v_Texture.Sample(v_Texture_sampler, I.Uv.xy) * I.v_Color;
    float3 Nmap = v_TextureNormal.Sample(v_TextureNormal_sampler, I.Uv.xy).rgb;
    float metallic = v_TextureMetal.Sample(v_TextureMetal_sampler, I.Uv.xy).r;
    float roughness = v_TextureRough.Sample(v_TextureRough_sampler, I.Uv.xy).r;

    // Geometric normal
    float3 geoN = normalize(I.Normal);

    // Light vector and geometric visibility
    float3 L = normalize(g_LightPosition.xyz - I.WorldPos);
    float realNdotL = dot(geoN, L);
    
    // Normal mapping
    float3 N = getNormalFromMap(Nmap, geoN, I.Tangent, I.Binormal);

    // View vector
    float3 V = normalize(g_CameraPosition.xyz - I.WorldPos);

    // F0 interpolation
    float3 F0 = lerp(float3(0.04, 0.04, 0.04), albedo.rgb, metallic);

    // Initialize color with ambient lighting
    float3 ambient = g_AmbientColor.xyz * g_ToneMapParams.z * albedo.rgb;
    float3 Lo = ambient;

    // Only add direct lighting if front-facing
    if (realNdotL > 0.0)
    {
        // Microfacet vectors
        float3 H = normalize(V + L);

        // Distance attenuation
        float dist = length(g_LightPosition.xyz - I.WorldPos);
        float range = g_LightRange.x;

        // Smooth attenuation: 0 at edge, 1 at center
        float attenuation = saturate(1.0 - (dist * dist) / (range * range));
        attenuation *= attenuation; // Optional: smoother falloff
        attenuation /= max(dist * dist, 0.01); // Keep inverse square behavior but clamped
        
        float3 radiance = g_LightColor.rgb * g_LightIntensity.x * attenuation;

        // Cook-Torrance BRDF
        float NDF = DistributionGGX(N, H, roughness);
        float G = GeometrySmith(N, V, L, roughness);
        float3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
        
        float3 kS = F;
        float3 kD = (1.0 - kS) * (1.0 - metallic);

        float denom = max(dot(N, V), 0.0) * max(dot(N, L), 0.0) * 4.0 + 0.0001;
        float3 spec = (NDF * G * F) / denom;

        // Final direct lighting contribution
        float NdotL = max(dot(N, L), 0.0);
        Lo += (kD * albedo.rgb / PI + spec) * radiance * NdotL;
    }

    // Apply tone mapping - choose one of these methods:
    // 1. ACES Filmic (recommended for most cases)
    Lo = ACESFilmicToneMapping(Lo);
    
    // 2. Exposure-based (uncomment to use instead)
    // Lo = ExposureToneMapping(Lo, g_ToneMapParams.x);
    
    // 3. Reinhard (uncomment to use instead)
    // Lo = ReinhardToneMapping(Lo);
    
    // 4. Filmic (uncomment to use instead)
    // Lo = FilmicToneMapping(Lo);

    // Gamma correction
    Lo = pow(Lo, float3(1.0 / g_ToneMapParams.y, 1.0 / g_ToneMapParams.y, 1.0 / g_ToneMapParams.y));

    O.Color = float4(Lo, albedo.a);
}