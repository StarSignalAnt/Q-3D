#define PI 3.14159265359

Texture2D v_Texture;
SamplerState v_Texture_sampler;
Texture2D v_TextureNormal;
SamplerState v_TextureNormal_sampler;
Texture2D v_TextureMetal;
SamplerState v_TextureMetal_sampler;
Texture2D v_TextureRough;
SamplerState v_TextureRough_sampler;

cbuffer Constants
{
    float4x4 g_ModelMatrix;
    float4x4 g_ViewMatrix;
    float4x4 g_ProjectionMatrix;
    float4x4 g_MVPMatrix;
    float4x4 g_NormalMatrix;

    float4 g_CameraPosition;
    float4 g_LightPosition;
    float4 g_LightColor;
    float4 g_LightIntensity;
    float4 g_LightRange;
};

struct PSInput {
    float4 Pos : SV_POSITION;
    float3 Uv : TEXCOORD0;
    float4 v_Color : TEXCOORD1;
    float3 WorldPos : TEXCOORD2;
    float3 Normal : TEXCOORD3;
    float3 Tangent : TEXCOORD4;
    float3 Binormal : TEXCOORD5;
};

struct PSOutput {
    float4 Color : SV_TARGET;
};

// Unpacks normal map and corrects green-channel handedness
float3 getNormalFromMap(float3 normalMap, float3 worldNormal, float3 worldTangent, float3 worldBinormal)
{
    float3 n = normalMap * float3(2.0, 2.0, 2.0) + float3(-1.0, -1.0, -1.0);
    float3x3 TBN = float3x3(worldTangent, worldBinormal, worldNormal);
    return normalize(mul(n, TBN));
}

float DistributionGGX(float3 N, float3 H, float rough)
{
    float a  = rough * rough;
    float a2 = a * a;
    float NdotH = max(dot(N,H),0.0);
    float NdotH2 = NdotH * NdotH;

    float num   = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;

    return num / denom;
}

float GeometrySchlickGGX(float NdotV, float rough)
{
    float r = rough + 1.0;
    float k = (r * r) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

float GeometrySmith(float3 N, float3 V, float3 L, float rough)
{
    float NdotV = max(dot(N,V), 0.0);
    float NdotL = max(dot(N,L), 0.0);
    float ggx1 = GeometrySchlickGGX(NdotL, rough);
    float ggx2 = GeometrySchlickGGX(NdotV, rough);
    return ggx1 * ggx2;
}

float3 fresnelSchlick(float cosTheta, float3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

void main(in PSInput I, out PSOutput O)
{
    // Sample material properties
    float4 albedo    = v_Texture.Sample(v_Texture_sampler, I.Uv.xy) * I.v_Color;
    float3 Nmap      = v_TextureNormal.Sample(v_TextureNormal_sampler, I.Uv.xy).rgb;
    float  metallic  = v_TextureMetal.Sample(v_TextureMetal_sampler, I.Uv.xy).r;
    float  roughness = v_TextureRough.Sample(v_TextureRough_sampler, I.Uv.xy).r;

    // Geometric normal
    float3 geoN = normalize(I.Normal);

    // Light vector and geometric visibility
    float3 L = normalize(g_LightPosition.xyz - I.WorldPos);
    float realNdotL = dot(geoN, L);
    if (realNdotL <= 0.0)
    {
        // Back-facing: no lighting
        O.Color = float4(0.0, 0.0, 0.0, albedo.a);
        return;
    }

    // Normal mapping
    float3 N = getNormalFromMap(Nmap, geoN, I.Tangent, I.Binormal);

    // View vector
    float3 V = normalize(g_CameraPosition.xyz - I.WorldPos);

    // F0 interpolation
    float3 F0 = lerp(float3(0.04,0.04,0.04), albedo.rgb, metallic);

    // Microfacet vectors
    float3 H = normalize(V + L);

    // Distance attenuation
 float dist = length(g_LightPosition.xyz - I.WorldPos);
float range = g_LightRange.x;

// Smooth attenuation: 0 at edge, 1 at center
float attenuation = saturate(1.0 - (dist * dist) / (range * range));
attenuation *= attenuation; // Optional: smoother falloff
attenuation /= max(dist * dist, 0.01); // Keep inverse square behavior but clamped
    float3 radiance = g_LightColor.rgb * g_LightIntensity.x * attenuation;

    // Cook-Torrance BRDF
    float NDF = DistributionGGX(N, H, roughness);
    float G   = GeometrySmith(N, V, L, roughness);
    float3 F  = fresnelSchlick(max(dot(H,V),0.0), F0);
    float3 kS = F;
    float3 kD = (1.0 - kS) * (1.0 - metallic);

    float denom = max(dot(N,V),0.0) * max(dot(N,L),0.0) * 4.0 + 0.001;
    float3 spec = (NDF * G * F) / denom;

    // Final shading
    float NdotL = max(dot(N,L), 0.0);
    float3 Lo = (kD * albedo.rgb / PI + spec) * radiance * NdotL;

    O.Color = float4(Lo, albedo.a);
}
