Texture2D v_Color;
SamplerState v_Color_sampler;

Texture2D v_Depth;
SamplerState v_Depth_sampler;

Texture2D v_Normal;
SamplerState v_Normal_sampler;

Texture2D v_Positions;
SamplerState v_Positions_sampler;

struct PSInput 
{ 
    float4 Pos : SV_POSITION;
    float3 Uv : TEX_COORD;
    float4 v_Color : COLOR2;
    float4x4 v_View : MATRIX1;
    float4x4 v_Proj : MATRIX5;
    float4x4 v_InvProj : MATRIX10;
    float4x4 v_InvView : MATRIX15;
    float4 v_Pars : TEXCOORD3;
    int4 v_IPars : TEXCOORD8;
    float4 v_ViewDir : VIEWDIR;
    float4 v_CamPos : CAMPOS;
};

struct PSOutput
{
    float4 Color : SV_TARGET;
};



float2 GetTexturePixelSize(Texture2D tex)
{
    uint width, height;
    tex.GetDimensions(width, height);
    return float2(width,height);
}

void main(in PSInput PSIn, out PSOutput PSOut)
{

 float maxDistance = 8;
  float resolution  = 0.3;
  int   steps       = 5;
  float thickness   = 0.5;

    float4x4 lens_Proj = PSIn.v_Proj;
  float4 uv = float4(0,0,0,0.0);

  float2 texSize = GetTexturePixelSize(v_Positions);
  float2 texCoord = PSIn.Pos.xy/texSize;


  float4 positionFrom     = v_Positions.SampleLevel(v_Positions_sampler, texCoord,0);
  float3 unitPositionFrom = normalize(positionFrom.xyz);


  float3 normal           = normalize(v_Normal.SampleLevel(v_Normal_sampler, texCoord,0).xyz);
  float3 pivot            = normalize(reflect(unitPositionFrom, normal));

    float4 positionTo = positionFrom;


    float4 startView = float4(positionFrom.xyz + (pivot *           0), 1);
  float4 endView   = float4(positionFrom.xyz + (pivot * maxDistance), 1);

//


  float4 startFrag      = startView;
       // Project to screen space.
        startFrag = mul(lens_Proj, startFrag);

       // Perform the perspective divide.
     startFrag.xyz /= startFrag.w;

// Convert screen-space XY coordinates to UV coordinates
startFrag.xy = startFrag.xy * 0.5 + 0.5;

// Convert UV coordinates to fragment/pixel coordinates
startFrag.xy *= texSize;

  float4 endFrag      = endView;
       //endFrag      = lensProjection * endFrag;
       endFrag = mul(lens_Proj, endFrag);

       endFrag.xyz /= endFrag.w;
       endFrag.xy   = endFrag.xy * 0.5 + 0.5;
       endFrag.xy  *= texSize;

    float2 frag  = startFrag.xy;
    uv.xy = frag / texSize;

   float deltaX = endFrag.x - startFrag.x;
float deltaY = endFrag.y - startFrag.y;
float useX = abs(deltaX) >= abs(deltaY) ? 1.0f : 0.0f;
float delta = lerp(abs(deltaY), abs(deltaX), useX) * clamp(resolution, 0.0f, 1.0f);
float2 increment = float2(deltaX, deltaY) / max(delta, 0.001f);

 float search0 = 0;
  float search1 = 0;

  int hit0 = 0;
  int hit1 = 0;

  float viewDistance = startView.y;
  float depth        = thickness;



for (int i = 0; i < (int)delta && i < 950; ++i) // Add a maximum iteration count
{
    frag += increment;
    float2 uv = frag / texSize;
    float4 positionTo = v_Positions.SampleLevel(v_Positions_sampler, uv,0);
    
    float search1 = lerp(
        (frag.y - startFrag.y) / deltaY,
        (frag.x - startFrag.x) / deltaX,
        useX
    );
    search1 = saturate(search1);
    
    float viewDistance = (startView.y * endView.y) / lerp(endView.y, startView.y, search1);
    float depth = viewDistance - positionTo.y;
    
    if (depth > 0 && depth < thickness)
    {
        hit0 = 1;
        break;
    }
    else
    {
        search0 = search1;
    }
}


      search1 = search0 + ((search1 - search0) / 2.0);

  steps *= hit0;

  //

  for (int i = 0; i < steps; ++i)
{
    float2 frag = lerp(startFrag.xy, endFrag.xy, search1);
    float2 uv = frag / texSize;
    float4 positionTo = v_Positions.SampleLevel(v_Positions_sampler, uv,0);
    
    float viewDistance = (startView.y * endView.y) / lerp(endView.y, startView.y, search1);
    float depth = viewDistance - positionTo.y;
    
    if (depth > 0 && depth < thickness)
    {
        hit1 = 1;
        search1 = search0 + ((search1 - search0) / 2.0f);
    }
    else
    {
        float temp = search1;
        search1 = search1 + ((search1 - search0) / 2.0f);
        search0 = temp;
    }
}

float visibility = 
    hit1
    * positionTo.w
    * (1.0f - max(dot(-unitPositionFrom, pivot), 0.0f))
    * (1.0f - saturate(depth / thickness))
    * (1.0f - saturate(length(positionTo - positionFrom) / maxDistance))
    * (uv.x < 0.0f || uv.x > 1.0f ? 0.0f : 1.0f)
    * (uv.y < 0.0f || uv.y > 1.0f ? 0.0f : 1.0f);

visibility = saturate(visibility);


    float3 fragCol = float3(1,0,0);

    float3 icol = v_Color.SampleLevel(v_Color_sampler,PSIn.Uv.xy,0).rgb;

    float3 rcol = v_Color.SampleLevel(v_Color_sampler,uv.xy,0).rgb;

    fragCol = icol+rcol;

    PSOut.Color = float4(fragCol, 1.0);
}