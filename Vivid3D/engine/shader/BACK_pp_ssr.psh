
Texture2D    v_Color;
SamplerState v_Color_sampler;

Texture2D    v_Depth;
SamplerState v_Depth_sampler;

Texture2D v_Normal;
SamplerState v_Normal_sampler;

Texture2D v_Positions;
SamplerState v_Positions_sampler;

struct PSInput 
{ 
  float4 Pos   : SV_POSITION;
  float3 Uv : TEX_COORD;
  float4 v_Color : COLOR2;
  float4x4 v_View : MATRIX1;
  float4x4 v_Proj : MATRIX5;
  float4x4 v_InvProj : MATRIX10;
   float4 v_Pars : TEXCOORD3;
  int4  v_IPars : TEXCOORD8;
  float4 v_ViewDir : VIEWDIR;
  float4 v_CamPos : CAMPOS;
 // float3 Norm : NORMAL0;x
};

struct PSOutput
{
    float4 Color : SV_TARGET;
};

#define MAX_STEPS 64
#define MAX_DISTANCE 10.0
#define ROUGHNESS_BIAS 0.1
#define DEPTH_BIAS 0.01

// Helper function to linearize depth
float LinearizeDepth(float depth, float near, float far)
{
    return (2.0 * near) / (far + near - depth * (far - near));
}


float3 CalculateSSR(float2 uv, Texture2D positionTexture, Texture2D normalTexture, Texture2D colorTexture, 
                    Texture2D depthTexture, SamplerState linearSampler, float4x4 sceneViewMatrix, 
                    float4x4 sceneProjectionMatrix, float4x4 inverseProjectionMatrix,
                    float3 cameraPosition, float nearPlane, float farPlane, float roughness)
{
    // Sample world position, normal, and depth
    float3 worldPos = positionTexture.Sample(linearSampler, uv).rgb;
    float3 worldNormal = normalTexture.Sample(linearSampler, uv).rgb;
    float depth = depthTexture.Sample(linearSampler, uv).r;

    // Calculate view direction in world space
    float3 viewDir = normalize(worldPos - cameraPosition);

    // Calculate reflection vector in world space
    float3 reflectionVector = reflect(viewDir, worldNormal);

    // Transform reflection vector to view space
    float3 viewSpaceReflection = mul(float4(reflectionVector, 0.0), sceneViewMatrix).xyz;

    // Project the view space reflection vector
    float4 projectedReflection = mul(float4(viewSpaceReflection, 0.0), sceneProjectionMatrix);
    float2 reflectionUV = (projectedReflection.xy / projectedReflection.w) * 0.5 + 0.5;

    // Calculate ray step in UV space
    float2 step = (reflectionUV - uv) / MAX_STEPS;

    float2 rayPos = uv;
    float3 reflectedColor = float3(0, 0, 0);
    bool hitFound = false;

    // Convert initial depth to view space
    float viewSpaceDepth = LinearizeDepth(depth, nearPlane, farPlane);

    // Ray marching loop
    [unroll(MAX_STEPS)]
    for (int i = 0; i < MAX_STEPS; i++)
    {
        rayPos += step;

        // Check if we're still on screen
        if (any(rayPos < 0) || any(rayPos > 1))
            break;

        // Sample depth at current position
        float sampleDepth = depthTexture.SampleLevel(linearSampler, rayPos, 0).r;
        float sampleViewSpaceDepth = LinearizeDepth(sampleDepth, nearPlane, farPlane);

        // Calculate the depth of the ray at this step
        float rayDepth = viewSpaceDepth + viewSpaceReflection.z * (float(i) / float(MAX_STEPS)) * MAX_DISTANCE;

        // Check for ray hit
        if (sampleViewSpaceDepth < rayDepth + DEPTH_BIAS)
        {
            hitFound = true;
            reflectedColor = colorTexture.SampleLevel(linearSampler, rayPos, roughness * 5.0 + ROUGHNESS_BIAS).rgb;
            break;
        }
    }

    // Apply roughness-based blending
    float blend = 1.0 - roughness;
    return hitFound ? lerp(reflectedColor, float3(0, 0, 0), blend) : float3(0, 0, 0);
}





float SampleDepth(float2 uv)
{
    float depth = v_Depth.Sample(v_Depth_sampler, uv).r;
    
    // Transform from device Z to view-space Z
    float viewSpaceZ = 2.0 * depth - 1.0;
    
    // Transform to linear 0-1 range
    // Note: You need to provide these values from your C++ code
    float nearZ = 0.1;  // Your near plane distance
    float farZ = 60.0;  // Your far plane distance
    float linearDepth = (2.0 * nearZ) / (farZ + nearZ - viewSpaceZ * (farZ - nearZ));
    
    return linearDepth;
}

// Note that if separate shader objects are not supported (this is only the case for old GLES3.0 devices), vertex
// shader output variable name must match exactly the name of the pixel shader input variable.
// If the variable has structure type (like in this example), the structure declarations must also be identical.
void main(in  PSInput  PSIn,
    out PSOutput PSOut)
{

 
    //float3 worldPos = v_Positions.SampleLevel(v_Positions_sampler,PSIn.Uv.xy, 0).xyz;
    //float3 normal = v_Normal.SampleLevel(v_Normal_sampler,PSIn.Uv.xy,0).xyz;
    //float rough =0.2f;

    float3 viewDir = PSIn.v_ViewDir.xyz;
     
     float3 col = CalculateSSR(PSIn.Uv.xy,v_Positions,v_Normal,v_Color,v_Depth,v_Color_sampler, 
                    PSIn.v_View,PSIn.v_Proj,PSIn.v_InvProj,PSIn.v_CamPos.xyz,PSIn.v_Pars.y,PSIn.v_Pars.z,0.3f);
                    
                


 
    //float3 col = CalculateSSR(PSIn.uv.xy,)
   
    float f1 = SampleDepth(PSIn.Uv.xy);
 

    float4 ffcol;

    ffcol.rgb = col+v_Color.Sample(v_Color_sampler,PSIn.Uv.xy).rgb;
    ffcol.a = 1.0;


    PSOut.Color = ffcol;


}

