Texture2D v_Color;
SamplerState v_Color_sampler;

Texture2D v_Depth;
SamplerState v_Depth_sampler;

Texture2D v_Normal;
SamplerState v_Normal_sampler;

Texture2D v_Positions;
SamplerState v_Positions_sampler;

struct PSInput 
{ 
    float4 Pos : SV_POSITION;
    float3 Uv : TEX_COORD;
    float4 v_Color : COLOR2;
    float4x4 v_View : MATRIX1;
    float4x4 v_Proj : MATRIX5;
    float4x4 v_InvProj : MATRIX10;
    float4x4 v_InvView : MATRIX15;
    float4 v_Pars : TEXCOORD3;
    int4 v_IPars : TEXCOORD8;
    float4 v_ViewDir : VIEWDIR;
    float4 v_CamPos : CAMPOS;
};

struct PSOutput
{
    float4 Color : SV_TARGET;
};

// Constants
static const float3 scale = float3(0.8, 0.8, 0.8);
static const float k = 19.19;
static const float fresnelExp = 5.0;
static const int ssr_binarySearchCount = 10;
static const int ssr_rayMarchCount = 50; // Adjust as needed
static const float ssr_step = 0.01; // Adjust as needed
static const float ssr_LLimiter = 0.1;
static const float ssr_minRayStep = 0.2;
static const float3 ssr_skyColor = float3(0, 0, 0);

// Helper functions
float3 getPosition(float2 UV)
{
    return v_Positions.SampleLevel(v_Positions_sampler, UV,0).xyz;
}

float2 binarySearch(inout float3 dir, inout float3 hitCoord, inout float dDepth, float4x4 proj)
{
    float depth;
    float4 projectedCoord;
    
    // Unroll loop manually for fixed iterations
    for (int i = 0; i < 350; i++) {
        float4 hitC = float4(hitCoord.xyz, 1.0);
        projectedCoord = mul(proj, hitC);

        projectedCoord.xy /= projectedCoord.w;
        projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;

        depth = getPosition(projectedCoord.xy).z;

        dDepth = hitCoord.z - depth;

        dir *= 0.5;
        if (dDepth > 0.0)
            hitCoord += dir;
        else
            hitCoord -= dir;
    }

    projectedCoord = mul(proj, float4(hitCoord, 1.0));
    projectedCoord.xy /= projectedCoord.w;
    projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;

    return float2(projectedCoord.xy);
}

float2 rayCast(float3 dir, inout float3 hitCoord, out float dDepth, float4x4 proj)
{
    dir *= ssr_step;

    // Unroll loop manually for fixed iterations
    for (int i = 0; i < 20; i++) {
        hitCoord += dir;

        float4 hitCoord4 = float4(hitCoord, 1.0);
        float4 projectedCoord = mul(proj, hitCoord4);

        projectedCoord.xy /= projectedCoord.w;
        projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;

        float depth = getPosition(projectedCoord.xy).z;

        dDepth = hitCoord.z - depth;

        if ((dir.z - dDepth) < 1.2 && dDepth <= 0.0)
        {
            return binarySearch(dir, hitCoord, dDepth, proj);
        }
    }

    return float2(-1.0, -1.0);
}

float3 hash(float3 a)
{
    a = frac(a * scale);
    a += dot(a, a.yzx + k);
    return frac((a.xxx + a.yyy) * a.zxy);
}

float fresnel(float3 direction, float3 normal)
{
    float3 halfDirection = normalize(normal + direction);
    float cosine = dot(halfDirection, direction);
    float product = max(cosine, 0.0);
    float factor = 1.0 - pow(product, fresnelExp);
    return factor;
}

void main(in PSInput PSIn, out PSOutput PSOut)
{
    float reflectionStrength = 0.7f;
    float3 normal = float3(v_Normal.SampleLevel(v_Normal_sampler, PSIn.Uv.xy,0).xyz);
    float3 viewPos = getPosition(PSIn.Uv.xy);

    float4 viewPos4 = float4(viewPos, 1.0);
    float4x4 viewMatrix = PSIn.v_View;


    float3 reflected = normalize(reflect(normalize(viewPos), normalize(normal)));

    float3 hitPos = viewPos;
    float dDepth=0;
    float2 coords = rayCast(reflected * max(-viewPos.z, ssr_minRayStep), hitPos, dDepth, PSIn.v_Proj);

    float L = length(getPosition(coords) - viewPos);
    L = clamp(L * ssr_LLimiter, 0.0f, 1.0f);
    float error = 1.0f - L;

    float3 c2 = v_Color.Sample(v_Color_sampler, coords.xy).rgb;

    float3 fragCol = float3(0.0, 0.0, 0.0);

    fragCol = c2+v_Color.Sample(v_Color_sampler,PSIn.Uv.xy).rgb;
  
    PSOut.Color = float4(fragCol, 1.0);
}