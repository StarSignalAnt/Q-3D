Texture3D v_Texture;
SamplerState v_Texture_sampler;


#define dx 1.0
#define PI 3.14159265359

cbuffer Constants
{
    float4x4 g_MVP;
  float4x4 g_ModelMatrix;
    float4x4 g_ViewMatrix;
    float4x4 g_ProjectionMatrix;
    float4 m_CameraPos;
    float4 m_SunDir;
    float4 m_VolStart;
    float4 m_VolSize;

};



struct PSInput
{
    float4 Pos : SV_POSITION;
    float3 Uv : TEX_COORD;
    float4 v_Color : COLOR2;
float3 WorldPos    : TEXCOORD1;
 
 // float3 Norm : NORMAL0;x
};

struct PSOutput
{
    float4 Color : SV_TARGET;
};

bool RayBoxIntersect(float3 rayOrigin, float3 rayDir, float3 boxMin, float3 boxMax, out float t0, out float t1)
{
    float3 invRayDir = 1.0 / rayDir;
    float3 tbot = invRayDir * (boxMin - rayOrigin);
    float3 ttop = invRayDir * (boxMax - rayOrigin);

    float3 tmin = min(ttop, tbot);
    float3 tmax = max(ttop, tbot);
    
    float2 t = max(tmin.xx, tmin.yz);
    t0 = max(t.x, t.y);

    t = min(tmax.xx, tmax.yz);
    t1 = min(t.x, t.y);

    return t0 <= t1;
}


void main(in PSInput PSIn,
    out PSOutput PSOut)
{
 //float3 worldDir = normalize(PSIn.WorldPos);

    float3 rayOrigin = m_CameraPos.xyz;
    float3 rayDir = normalize(PSIn.WorldPos - rayOrigin);
    rayDir.y = -rayDir.y;
    //rayDir.x = -rayDir.x;
    rayDir.z = -rayDir.z;

     float3 boxMin = m_VolStart.xyz;
    float3 boxMax = m_VolStart.xyz + m_VolSize.xyz;
    float t_min, t_max;

    // If the ray doesn't hit our cloud volume at all, discard the pixel.
    if (!RayBoxIntersect(rayOrigin, rayDir, boxMin, boxMax, t_min, t_max))
    {
        clip(-1);
    }
    t_min = max(t_min, 0.0);

 float accumulatedDensity = 0.0;
    int numSteps = 64;
    float stepSize = (t_max - t_min) / (float)numSteps;
    
    // Start marching from the volume entry point
    float3 currentPos = rayOrigin + rayDir * t_min;

    for (int i = 0; i < numSteps; i++)
    {
        // Convert world position to UVW coordinates (0-1 range) for texture sampling
        float3 uvw = (currentPos - boxMin) / m_VolSize.xyz;
        
        // Sample the 3D noise texture to get the density at this point
        float density = v_Texture.Sample(v_Texture_sampler, uvw).r; // .r because we used an R8 format
        
        accumulatedDensity += density;
        
        // Move to the next sample point
        currentPos += rayDir * stepSize;
    }

    float densityFactor = 0.1; // A tweakable value to control overall opacity
    float alpha = 1.0 - exp(-accumulatedDensity * stepSize * densityFactor);

    // Output a simple white color with the calculated alpha for our test sphere
    PSOut.Color = float4(1.0, 1.0, 1.0, alpha);


 
}