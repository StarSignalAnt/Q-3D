Texture3D v_Texture;
SamplerState v_Texture_sampler;


#define dx 1.0
#define PI 3.14159265359

cbuffer Constants
{
    float4x4 g_MVP;
  float4x4 g_ModelMatrix;
    float4x4 g_ViewMatrix;
    float4x4 g_ProjectionMatrix;
    float4 m_CameraPos;
    float4 m_SunDir;
    float4 m_VolStart;
    float4 m_VolSize;

};



struct PSInput
{
    float4 Pos : SV_POSITION;
    float3 Uv : TEX_COORD;
    float4 v_Color : COLOR2;
float3 WorldPos    : TEXCOORD1;
 
 // float3 Norm : NORMAL0;x
};

struct PSOutput
{
    float4 Color : SV_TARGET;
};

float HenyeyGreenstein(float cos_angle, float g)
{
    float g2 = g * g;
    return (1.0 - g2) / (4.0 * 3.14159265 * pow(1.0 + g2 - 2.0 * g * cos_angle, 1.5));
}



bool RayBoxIntersect(float3 rayOrigin, float3 rayDir, float3 boxMin, float3 boxMax, out float t0, out float t1)
{
    float3 invRayDir = 1.0 / rayDir;
    float3 tbot = invRayDir * (boxMin - rayOrigin);
    float3 ttop = invRayDir * (boxMax - rayOrigin);

    float3 tmin = min(ttop, tbot);
    float3 tmax = max(ttop, tbot);
    
    float2 t = max(tmin.xx, tmin.yz);
    t0 = max(t.x, t.y);

    t = min(tmax.xx, tmax.yz);
    t1 = min(t.x, t.y);

    return t0 <= t1;
}


void main(in PSInput PSIn,
    out PSOutput PSOut)
{
 //float3 worldDir = normalize(PSIn.WorldPos);

    float3 rayOrigin = m_CameraPos.xyz;
    float3 rayDir = normalize(PSIn.WorldPos - rayOrigin);
    rayDir.y = -rayDir.y;
    //rayDir.x = -rayDir.x;
    rayDir.z = -rayDir.z;

     float3 boxMin = m_VolStart.xyz;
    float3 boxMax = m_VolStart.xyz + m_VolSize.xyz;
    float t_min, t_max;

    // If the ray doesn't hit our cloud volume at all, discard the pixel.
    if (!RayBoxIntersect(rayOrigin, rayDir, boxMin, boxMax, t_min, t_max))
    {
        clip(-1);
    }
    t_min = max(t_min, 0.0);
     float daylight_factor = saturate(-m_SunDir.y);

    // 3. Raymarch for Lighting
    int numSteps = 64;
    float stepSize = (t_max - t_min) / (float)numSteps;
    float3 currentPos = rayOrigin + rayDir * t_min;

    float3 sun_color = float3(1.0, 0.95, 0.85);
    float3 ambient_color = float3(0.4, 0.5, 0.65);
    float eccentricity = 0.6;
    float density_factor = 0.1;

    // --- NEW: Define a very dim light color for nighttime ---
    float3 night_light = float3(0.02, 0.03, 0.05);

    float4 final_color = float4(0, 0, 0, 1);

    for (int i = 0; i < numSteps; i++)
    {
        float3 uvw = (currentPos - boxMin) / m_VolSize.xyz;
        float density = v_Texture.Sample(v_Texture_sampler, uvw).r;


        if (density > 0.01)
        {
            float cos_angle = dot(rayDir, -m_SunDir.xyz);
            float phase = HenyeyGreenstein(cos_angle, eccentricity);

            // --- MODIFIED: Interpolate between day and night lighting ---

            // Define the full daytime light (ambient + sun)
            float3 daytime_light = ambient_color + phase * sun_color;
            
            // Linearly interpolate between the dim night light and the bright day light
            // based on the sun's position.
            float3 light_at_step = lerp(night_light, daytime_light, daylight_factor);

            float transmittance = exp(-density * stepSize * density_factor);
            
            final_color.rgb += density * light_at_step * final_color.a * stepSize * density_factor;
            final_color.a *= transmittance;
        }

        currentPos += rayDir * stepSize;
    }

    PSOut.Color = float4(final_color.rgb, 1.0 - final_color.a);

 
}